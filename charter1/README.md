本书精髓：旨在帮助读者了解，当在系统上执行以下hello程序时，系统发生了什么，以及为什么。
```
#include<stdio.h>
int main(){
    printf("hello,world\n");
}
```


## 1.1一切都是二进制
在计算机中，如果要表示中宇宙中的一切信息，其本质都是用二进制位来表示和存储的，举例如10101011；  
我们来举个例子：假如我们自己写了一个打印**hello world**的源代码程序，然后将这个源代码文件保存。
这个时候，这个文件就被保存到了计算机的硬盘中，程序中的每个字符，在计算机底层都是用二进制来表示和存储的。  
下面，就让我们一起以一个hello.c的源代码文件为例子，来深入了解下，文件中的内容在计算机中是如何表示的。 

## /root/hello.c
```
#include<stdio.h>
void main(){
    printf("hello world\n");
}
```
## 查看hello.c源码文件二进制表示
首先我们开门见山，直接用linux下的xxd工具来查看
```
[root@jordy ~]# xxd /root/hello.c 
0000000: 2369 6e63 6c75 6465 3c73 7464 696f 2e68  #include<stdio.h
0000010: 3e0a 766f 6964 206d 6169 6e28 297b 0a09  >.void main(){..
0000020: 7072 696e 7466 2822 6865 6c6c 6f20 776f  printf("hello wo
0000030: 726c 645c 6e22 293b 0a7d 0a              rld\n");.}.

```
通过以上输出，我们清楚地看到，我们编写的源代码被保存在计算机的文件中
源代码文件本质上也是一系列的二进制序列。
比如第一个字符#，它对应的ASCII码值的十进制是35，上面是用16进制表示每个字节的
35的16进制是23，即表示第一个字符#
同样地，第二个字节是69，我们算得它对应的十进制是（6 * 16 + 9 ）105
查看ASCII码表，105表示的是字符i，以此类推。

下面让我们简单实现另外一个工具类程序，该程序的功能是读取/root/hello.c源文件的内容，并按不同的格式输出，如二进制，十六进制，ASCII十进制等等
```        
package main
  
import (
    "fmt"
    "io/ioutil"
    "log"
    "os"
)

func main() {
    file, err := os.Open("/root/hello.c")
    if err != nil {
        log.Fatal(err)
    }
    data, err := ioutil.ReadAll(file)
    if err != nil {
        log.Fatal(err)
    }
    dataByte := []byte(data)
    length := len(dataByte)
    for i := 0; i < length; i++ {
        fmt.Printf("%8x", dataByte[i])
        fmt.Printf(" ")
        if (i+1)%16 == 0 {
            fmt.Printf("\n")
        }
    }
    fmt.Println("\n")
    for i := 0; i < length; i++ {
        fmt.Printf("%8b", dataByte[i])
        fmt.Printf(" ")
        if (i+1)%16 == 0 {
            fmt.Printf("\n")
        }
    }
    fmt.Println("\n")
    for i := 0; i < length; i++ {
        fmt.Printf("%8v", dataByte[i])
        fmt.Printf(" ")
        if (i+1)%16 == 0 {
            fmt.Printf("\n")
        }
    }

    fmt.Println("\n")
}

```
运行该程序
```
[root@jordy ~]# go run show_bytes.go
```
得到如下结果：
```
[root@jordy ~]# go run show_bytes.go 
      23       69       6e       63       6c       75       64       65       3c       73       74       64       69       6f       2e       68 
      3e        a       76       6f       69       64       20       6d       61       69       6e       28       29       7b        a        9 
      70       72       69       6e       74       66       28       22       68       65       6c       6c       6f       20       77       6f 
      72       6c       64       5c       6e       22       29       3b        a       7d        a 

  100011  1101001  1101110  1100011  1101100  1110101  1100100  1100101   111100  1110011  1110100  1100100  1101001  1101111   101110  1101000 
  111110     1010  1110110  1101111  1101001  1100100   100000  1101101  1100001  1101001  1101110   101000   101001  1111011     1010     1001 
 1110000  1110010  1101001  1101110  1110100  1100110   101000   100010  1101000  1100101  1101100  1101100  1101111   100000  1110111  1101111 
 1110010  1101100  1100100  1011100  1101110   100010   101001   111011     1010  1111101     1010 

      35      105      110       99      108      117      100      101       60      115      116      100      105      111       46      104 
      62       10      118      111      105      100       32      109       97      105      110       40       41      123       10        9 
     112      114      105      110      116      102       40       34      104      101      108      108      111       32      119      111 
     114      108      100       92      110       34       41       59       10      125       10 


```
我们清晰地看到，我们手动用程序输出hello.c文件的二进制表示，跟上述直接用xxdg工具生成的二进制序列是一模一样的。





## 1.4
###1.4.1总线
这里主要明白32和64位的来源：
我们首先来学习下面的一段描述：
贯穿整个系统的是一组电子管道，称做总线，它携带信息字节并负责在各个部件间传递。     
通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，在各个系统中的情况都不尽相同。  
现在的大多数机器字长有的是4个字节（32位），有的是8个字节（64位）。为了讨论的方便，假设字长为4个字节，并且总线每次只传送1个字。
  

